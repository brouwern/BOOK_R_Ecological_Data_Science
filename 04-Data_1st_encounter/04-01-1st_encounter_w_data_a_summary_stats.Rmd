# (PART) Data analysis: a first encounter {-}

### {-}

In this section we will tackle a typical data analysis problem: determining if two groups of organisms an be considering statistically differnet from each other.  We will use data from a paper titled "Sperm competition and the evolution of precopulatory weapons: Increasing male density promotes sperm competition and reduces selection on arm strength in a chorusing frog" by Buzatto et al (2015).  The end goal is to compare the size of the arms on female and male frogs.  First, though, we will get to know the data by calcualting summary statistics and making exploratory graphs.  We will then carry out a t-test and grabble with with the meaning and interpretation of the output is.  Finally, we'll explore how best to plot the output of your t-test.

1. Data exploration with summary statistics
1. Graphical data exploration
1. Plotting means and measures of variation and precisions
1. T-test
1. Plotting the output of a t-test


# Data Analysis Encounter: Summary Statistics


```{r , include=F, echo = F}
knitr::opts_chunk$set(echo = TRUE,
                      tidy = F, 
                      warning = F,
                      error = F,
                      message = F,
                      #cache = TRUE,
                      fig.margin = TRUE,
                      #results="hide",
                      fig.width = 4,
                      fig.height = 3)
```

| **Nathan Brouwer, Phd**
| brouwern@gmail.com
| https://github.com/brouwern
| Twitter: lobrowR

## Introduction

### Goals and objectives

Get to know the frogarms dataset and learn how to calculat summary statistics using basic R functions (eg summary() ) and also with dplyr.

### Outline

1. Load packages and data
1. Subset data
1. Calculate summary stats on columns
1. Use dplyr
1. Calcualte summary stats by group using

### Packages

* devtools
* wildlifeR (from GitHub)

### Functions

* devtools::install_github()
* wildlifeR::make_my_data2L
* dim
* nrow
* ncol
* head
* tail
* names
* summary
* median()
* min()
* max()
* var()
* sd()
* range()
* nrow() or length() (for sample size)
* dplyr::summarise(), dplyr::summarize()
* group_by()
* dplyr::n()

## Preliminaries

First, we nee to install the necessary packages.  The data are in a package stored on GitHub called wildlifeR.  The devtools package is needed for downloading from github.  We'll also use dplyr for grouping data and calcualting summary statistics.

### Load packages

You might have to install or re-install wildlifeR using install.packages()
```{r eval=F}
library(devtools)
install_github("brouwern/")
```

Recall that downloiading a package and actually loading it into R's active memory are different things.  To actually use the pakcage you need to use the librar() command
```{r echo = F}
library(wildlifeR)
```

### Load data

The data we'll be using is in a dataset called "frogarms" in the wildlifeR package.

```{r}
data(frogarms)
```

You can find out information about these data using the ? command.  Note that there are no parenthese required for this.

```{r echo = F}
?frogarms
```


### Subset your data

The function make_my_data2L() in the wildlfieR will extact out a random subset of the data.  Change "my.code" to your school email address, minus the "@pitt.edu" or whatever your affiliation is.
```{r}
my.frogs <- frogarms
my.frogs <- make_my_data2L(dat = frogarms,
                           my.code = "nlb24", # <=  change this!
                           cat.var = "sex",
                           n.sample = 20,
                           with.rep = FALSE)

```

n.sample is set to 20.  This is set up to extract 20 unique individuals of each sex.  Check that you dataframe is 2*20 = 40 rows using the dim() command.

```{r}
dim(my.frogs)
```


## A 1st encounter with R: getting to know your dataframe


### Dataframe dimension

The following commands tell you the row x column dimension, number of rows, and number of columns.

```{r}
dim(my.frogs)
nrow(my.frogs)
ncol(my.frogs)
```

----------

### Optional: accessing elements of objects

The following section is optional.

The commands dim, nrow and ncol all generate objects that display informatio on the dimension of a dataframe.  dim() produces and object that is a "vector" that is 1 row x 2 elemtns in size.  We can select these individual elements using square brackets

The full dim() output
```{r}
dim(my.frogs)
```

The 1st element of the dim() output

```{r}
dim(my.frogs)[1]
```

The 2nd element

```{r}
dim(my.frogs)[2]
```

Both elements

```{r}
dim(my.frogs)[1:2]
```


Another way to get both elements

```{r}
dim(my.frogs)[c(1,2)]
```


What happens when you execute this command?
```{r}
dim(my.frogs)[c(2,1)]
```


**End optional section**

----------

### Dataframe preview

The head() and tail() commands give up short previews of the dataframe

The top few rows
```{r}
head(my.frogs)
```

The bottom few rows
```{r}
tail(my.frogs)
```

names() just gives of the names
```{r}
names(my.frogs)
```


Again, if you want ot know what the column names are, use the ? command
```{r eval = F}
?my.frogs
```


## A 1st encounter with R: summary statistics

R is a giant calculater.  There are commands for mean, median, standard deviation etc.  The summary() command creates a handy summary of an entire dataframe.


### Overall summary

Whole dataframe
```{r}
summary(my.frogs)
```

We can look at just a single column by specifying it using the syntax "dataframe$column.names" where the dataframe and column are sperated by a dollar sig ($).  (note that it prints it out horizontally, not vertially)

```{r}
summary(my.frogs$mass)
```


We used the make_my_data2L command to make a unique subset of the data.   compare the mass values in your subset to the original data

```{r}
summary(my.frogs$mass)
summary(frogarms$mass)
```

----------

### Optional: stacking things with rbind()

**This is optional**

Handy trick: stack up the summaries with rbind()

```{r}
rbind(summary(my.frogs$mass),
      summary(frogarms$mass))
```

You can even flip them on their side like this

```{r}
my.summaries <- rbind(summary(my.frogs$mass),
                      summary(frogarms$mass))
```

```{r}
t(my.summaries)
```


**End optional section**

----------

### Individual summary stats

You can get individual summary statistics using various commands named after the statistic

The mean of a coulumn

```{r}
mean(my.frogs$mass)
```


The variance
```{r}
var(my.frogs$mass)
```


Other include: 

* median()
* min()
* max()
* var()
* sd()
* range()
* nrow() or length() (for sample size)

Note that range() returns two values in a vector
```{r}
range(my.frogs$mass)
```

### The standard error (SE) in R 

Note that R doesn't return a very common statistic, the standard error (SE). The SE is the standard deviation (SD) deivided by the square root of the sample size.  You can get the same size using the length() command.

You can therefore calcualte the SE like this: 

```{r}
sd(my.frogs$mass)/sqrt(length(my.frogs$mass))
```


----------

In the following two optional sections you can

* try to find a package with an SE fucntion
* try to write a function that calcualtes the SE for you

### OPTIONAL: Find a package the calcualtes the SE

Since R lacks a an SE function many packages include it.  For example, the plotrix package has a function std.error().  See if you can download the package, install it using library(), and use the std.error().  See the help package for more info (?std.error)

### OPTIONAL: Write your own SD function

Write a function for calculationg the SD

Here's a function that takes a single arguement "dat_column"
```{r}
#NOTE: this is optional
my_sd1 <- function(dat_column){
  sd(dat_column)/sqrt(length(dat_column))
}
```

To use it, you need to give it the dataframe and the column seperated by a $

```{r}
my_sd1(my.frogs$mass)
```

Here's a function that takes 2 arguements: the dataframe, and the name of the column  Note that the name of the column needs to be in quotes


```{r}
my_sd2 <- function(dat, column){
  sd(dat[,column])/sqrt(length(dat[,column]))
}

```

You can use the function like this:
```{r}
my_sd2(my.frogs, "mass")
```



Here's a fancier function that let's you specify how much to round off the results.  I've set the default rounding to 3 digits.

```{r}
my_sd3 <- function(dat, column, digits.round = 3){
  se <- sd(dat[,column])/sqrt(length(dat[,column]))
  round(se, digits = digits.round)
}

```

The function runs like this.
```{r}
my_sd3(my.frogs, "mass")
```


Note that in all of functions as long as I give the function the arguements in the same order they are set up in the code that defines the function, I don't need to provide the names.  This save typing.  Compare these results

```{r eval=FALSE, echo=FALSE}
my_sd3(my.frogs, "mass")
my_sd3(dat = my.frogs, column =  "mass")
my_sd3(column =  "mass", dat = my.frogs)
my_sd3("mass", my.frogs)
```



**End optional section**

----------



  
## A 1st encounter with dplyr
  
dplyr is a package that provides numerous functions for manipulating data.  We will use two handy functions

* summarize() / summarise()
* group_by()

dplyr can use a handy sytax that involes "pipes".  You can string together R commands using the pipe function %>%
  
When using pipes, you start with a dataframe and follow it with an action you want done to it.  So, for example, previously when we wanted the mean of the "mass"" column we did this

```{r eval = F}
mean(my.frogs$mass)
```

Which is kind of read like a normal mathematical equation or function, where you start from inside the parentheses and work out.  

Eg, this.is.read.2nd(this.is.read.1st)

R let's you nest as many functions as you wnat.  If i want to round the wrap "mean(my.frogs$mass)" in "round(...)""

```{r}
round(mean(my.frogs$mass))
```


Using pipes to get the mean I write things more like a sentence

Eg, this.is.read.1st %>% this.is.read.2nd

```{r}
my.frogs$mass %>% mean #note parentheses after mean!
```

Which reads kind of like "Take the mass column and the datagrame and apply the mean() function to it."    

To round the mean we would do this

```{r}
my.frogs$mass %>% mean %>% round
```

Which read left to right like a sentence is "Take the mass column, calcualte the mean and then round it."

Note that the rond() command has an arguement for how many digits you want to round to.  You include that in the parantehes

```{r}
my.frogs$mass %>% mean() %>% round(digits = 2)
```

#### dplyr's summarize() command

Instead of mean(data$column) we can use summarise() (for the British) or summarize(), plus pipes.

We can get the grand mean of just the mass column by loading dplyr using library() and then using the summarise() commnad
```{r}
library(dplyr)
my.frogs %>% summarise(mean(mass))
```

This is maybe more complicated than "mean(my.frogs$mass)" or my.frogs$mass %>% mean,  but overall the pipe framework and summarise pays off  when combined with group_by() in the next section

## dplyr's group_by() function

For some more info on group_by see

* https://www.r-bloggers.com/using-r-quickly-calculating-summary-statistics-with-dplyr/
* https://www3.nd.edu/~steve/computing_with_data/24_dplyr/dplyr.html
http://www.datacarpentry.org/R-genomics/04-dplyr.html

We can use group_by() to split things up by a categorical variable (sex, color, year).  Here, we can say "take my.frogs, split up the data by the sex column, and apply the mean() function to each subset."  

```{r}
my.frogs %>%            #the data
  group_by(sex) %>%     #the group_by() function applied to the sex column
  summarise(mean(mass)) #the mean() function, applied to mass.
```

This might be a bit abstract when you first do it.  Again, where starting with our whole datefarme, then its piped over to group_by(), which splits it essentially into a male and a female subset.  Then the mean() function is applied to each of these subsets. 

Note that the column heading in the output `mean(mass)`, which is what is in summarise().

A handy thing about summarise is you can pass it lables.  The following code adds a sensible lable by changing "summarise(mean(mass))" to "summarise(mass.mean = mean(mass))", where "mass.mean = ..." defines the label.

```{r}
my.frogs %>% 
  group_by(sex) %>%
  summarise(mass.mean = mean(mass))
```

You can lable things anything, eg "puppies".
```{r}
my.frogs %>% 
  group_by(sex) %>%
  summarise(puppies = mean(mass))
```


You can pass any summary function to summarise().  We can give it sd() to get the sd of mass by sex.  Note that I define the column names using "mass.sd = ..."

```{r}
my.frogs %>% 
  group_by(sex) %>%
  summarise(mass.sd = sd(mass))
```


What makes dplyr::group_by and summarize() really powerful is that you can pass it *multiple*. summary functions at the same time.  Here, I'll pass mean() and sd(), naming both.
```{r}
my.frogs %>% 
  group_by(sex) %>%
  summarise(mass.mean = mean(mass),
            mass.sd = sd(mass))
```


dplyr also has a handy function n() for getting your sample size.
```{r}
my.frogs %>% 
  group_by(sex) %>%
  summarise(mass.mean = mean(mass),
            mass.sd = sd(mass),
            n = n())
```


--------------

### OPTIONAL: Using novel function with dplyr

**This section is optional**

If you have defined the my_sd1() function above you can pass it to summarise() too.

```{r}
my.frogs %>% 
  group_by(sex) %>%
  summarise(mass.mean =  my_sd1(mass))

```


**End optional section**

--------------
  
  
  
------------

## OPTIONAL: ALternatives to dplyr 

**This section is optional**

Most everybody is switching to dplyr.  Below are some other idioms you may see others use or encouter in older books.  
  
### doBy::summaryBy

The doBy package has a nice syntax.  I don't really see many people use it.  Be sure to download it first.

```{r eval = FALSE}
library(doBy)
summaryBy(mass ~ sex,data = my.frogs, FUN = mean)

summaryBy(mass ~ sex,data = my.frogs, FUN = c(mean,sd))
```


### tapply()

tapply is pretty old school.
```{r}
tapply(X = my.frogs$mass,INDEX = my.frogs$sex, FUN = mean)
```


### reshape2::dcast

What I've used most of my career thus far.  Am slowly switch to dplyr.
```{r}
library(reshape2)
dcast(data = my.frogs,
      formula = sex ~ .,
      value.var = "mass",
      fun.aggregate  = mean)
```


**End optional section**

------------
  
  